[TOC]



# 2025.4.24 力扣1Mid

## 【双指针、哈希】[力扣2799. 统计完全子数组的数目](https://leetcode.cn/problems/count-complete-subarrays-in-an-array/)

### 方法：双指针

- 时间复杂度O(n)
- 移动右端点：对于每个位置i，j++直到不满足now_num_set.size() <= all_num_set.size()，等于时候更新答案。
- 左端点移出时候记得消掉now_num中其出现的次数
- 一个特别重要的点是，一旦右侧端点到达了临界值（满足当前完全子数组数目等于整体完全子数组数目）后，之后移动右端点到达的全部是合法的，因此对答案的贡献是n - j + 1

### 代码：

```c++
class Solution {
public:
    int countCompleteSubarrays(vector<int>& nums) {
        unordered_map<int, int> now_num, all_num;
        for (auto x : nums) {
            all_num[x] ++;
        }

        int n = nums.size();
        int j = 0;
        int res = 0;
        for (int i = 0; i < n; ) {
            // 移动右指针
            while (j < n && now_num.size() < all_num.size()) {
                now_num[nums[j]] ++;
                j ++;
            }
            // 统计更新答案：此时的j的下标正好是合法的第一个位置，从j到结尾都是合法的
            if (now_num.size() == all_num.size()) {
                res += n - j + 1;
            }
            // 移动左指针
            now_num[nums[i]] --;
            if (now_num[nums[i]] == 0) {
                now_num.erase(nums[i]);
            }
            i ++;
        }

        return res;
    }
};
```



## 小结：

开始比较快想出来O（n^2），但是审题不仔细，忽视了右侧端点合法后就不用继续遍历了。另外右侧指针我们要找的是第一个满足条件的，因此`while (j < n && now_num.size() < all_num.size())`中应当用`now_num.size() < all_num.size()`而非小于等于。

# 2025.4.23 力扣1Easy

## 【模拟、哈希】[力扣1399. 统计最大组的数目](https://leetcode.cn/problems/count-largest-group/)

### 方法：模拟

- 观察到n<=1E4, 想到模拟。
- 从1到n依次求数位和，使用哈希表记录不同数位和出现的次数记录为`digital_sum`。同时不断更新每个数位和的出现次数，并记录全局最大的数位和出现次数，记录为`cnt`。
- 遍历哈希表，统计“数字数目并列最多的组”（数位和出现次数等于 `cnt`的），记录为`res`

### 代码：

```c++
class Solution {
public:
    int countLargestGroup(int n) {
        map<int, int> digital_sum;
        int cnt = -1;
        for (int i = 1; i <= n; i++) {
            int t = i, x = 0;
            while (t) { 
                x += t % 10; 
                t /= 10;
            }
            digital_sum[x] ++;
            cnt = max(cnt, digital_sum[x]);
        }

        int res = 0;
        for (auto [_, val] : digital_sum) {
            res += (val == cnt);
        }

        return res;
    }
};
```



## 小结：

感觉这个题题干表述不是很好，自己语言组织上有所欠缺。没想到dp之类的解法，找规律越找越复杂，还是暴力模拟干掉了。



# 2025.4.22 力扣1Hard

## 【数论、问题转化】[力扣2338. 统计理想数组的数目](https://leetcode.cn/problems/count-the-number-of-ideal-arrays/)

### 方法：数学推导

1. 转化为商分数组序列种类数
2. e个小球放到n个独立有区别盒子，允许重复放的方案数<=>n+e个小球放到n个独立有区别盒子，不允许有空盒的方案数
3. 根据乘法原理，质因子分解进行插隔板时相互独立
4. 枚举商分数组成绩x, 其中x <= maxValue
5. 注意取模

### 代码：

```c++
constexpr int MOD = 1E9 + 7;
constexpr int MAX_N = 1E4;
constexpr int MAX_E = 13;
using i64 = long long;
/*
题解来自灵茶山艾府：https://leetcode.cn/problems/count-the-number-of-ideal-arrays/solutions/1659088/shu-lun-zu-he-shu-xue-zuo-fa-by-endlessc-iouh

(1) 转化为商分数组序列种类数
(2) e个小球放到n个独立有区别盒子，允许重复放的方案数<=>n+e个小球放到n个独立有区别盒子，不允许有空盒的方案数
(3) 根据乘法原理，质因子分解进行插隔板时相互独立
(4) 枚举商分数组成绩x, 其中x <= maxValue
(5) 注意取模
*/
class Solution {
public:
    int idealArrays(int n, int maxValue) {
        vector<vector<int> > EXP(MAX_N + 1);
        vector<vector<int> > C(MAX_N + MAX_E, vector<int>(MAX_E + 1));
        // EXP[x] 为 x 分解质因数后，每个质因数的指数
        for (int x = 2; x <= MAX_N; x++) {
            int t = x;
            for (int i = 2; i * i <= t; i++) {
                int e = 0;
                for (; t % i == 0; t /= i) {
                    e++;
                }
                if (e) {
                    EXP[x].push_back(e);
                }
            }
            if (t > 1) {
                EXP[x].push_back(1);
            }
        }
         // 预处理组合数
        for (int i = 0; i < MAX_N + MAX_E; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= min(i, MAX_E); j++) {
                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
            }
        }

        i64 ans = 0;
        for (int x = 1; x <= maxValue; x++) {
            i64 res = 1;
            for (auto exp : EXP[x]) {
                res = res * C[n + exp - 1][exp] % MOD;
            }
            ans += res;   
        }

        return ans % MOD;
    }
};
```

## 小结

1. 涉及到概率论基础、等价问题转换、组合数、乘法原理，感觉目前独自做不出来。
2. 记录一个概率论的结论：e个小球放到n个独立有区别盒子，允许重复放的方案数 <=> n+e个小球放到n个独立有区别盒子，不允许有空盒的方案数

# 2025.4.21 力扣2Mid

复健Day1 ，力扣2Mid，耗时1.5h（加上写笔记2h）

## 【排序、区间问题、思维】[力扣56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

### 方法①：排序＋思维

首先对区间数组`intervals`从小到大排序，然后建立最终答案数组`merged`，遍历`intervals`，对于每个子区间`intervals[i]`和答案数组的最后一个`merged[last]`，有如下两种情况：

- 相交：`merged[last]_r ≥ intervals[i]_l`，进行合并（更新`merged[last]_r = max(merged[last]_r, r)`）
- 独立：`merged[last]_r < intervals[i]_l`，即二者相互独立，将`intervals[i]`插入到`merged`数组的最后位置即可

ps: `XXX_l` 与 `XXX_r`分别表示对应区间的左右端点



### 方法②：暴力传递左右端点法

画图发现，连续区间内部可以有若干相交的子区间。我们可以把同一个连续区间内最终的右端点or左端点，传递给区间内部的每个子区间。这样操作后，我们得到包含若干重复区间的结果，进行去重即可得到答案。



### 代码：

```c++
// 方法1   
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int> > merged;
        if (intervals.empty()) {
            return merged;
        }

        sort(intervals.begin(), intervals.end());
        for (int i = 0; i < intervals.size(); i++) {\
            if (merged.empty() || intervals[i][0] > merged.back()[1]) {
                merged.push_back({intervals[i][0], intervals[i][1]});
            } else {
                merged.back()[1] = max(merged.back()[1], intervals[i][1]);
            }
        }
        
        return merged;
    }
};

---
// 方法2    
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // 暴力模拟合并
        sort(intervals.begin(), intervals.end());
        int max_right = 0;
        for (int i = intervals.size() - 1; i >= 0; i--) {
            auto &temp = intervals[i];
            auto &l = temp[0];
            auto &r = temp[1];
            if (i - 1 >= 0) {
                auto &prev_temp = intervals[i - 1];
                auto &prev_l = prev_temp[0];
                auto &prev_r = prev_temp[1];
                // 如果相交
                if (prev_r >= l) {
                    cout << i << endl;
                    prev_r = max(prev_r, r);
                    r = max(prev_r, r);
                    l = min(l, prev_l);
                }
            }
        }
        // 从右向左传递
        for (int i = 0; i < intervals.size(); i++) {
            auto &temp = intervals[i];
            auto &l = temp[0];
            auto &r = temp[1];
            if (i + 1 < intervals.size()) {
                auto &nxt_temp = intervals[i + 1];
                auto &nxt_l = nxt_temp[0];
                auto &nxt_r = nxt_temp[1];
                // 如果相交
                if (nxt_l <= r) {
                    nxt_l = min(nxt_l, l);
                    nxt_r = max(nxt_r, r);
                    r = max(r, nxt_r);
                }
            }
        }
        // 从左向右传递
        for (int i = intervals.size() - 1; i >= 0; i--) {
            auto &temp = intervals[i];
            auto &l = temp[0];
            auto &r = temp[1];
            if (i - 1 >= 0) {
                auto &prev_temp = intervals[i - 1];
                auto &prev_l = prev_temp[0];
                auto &prev_r = prev_temp[1];
                // 如果相交
                if (prev_r >= l) {
                    cout << i << endl;
                    prev_r = max(prev_r, r);
                    r = max(prev_r, r);
                    l = min(l, prev_l);
                }
            }
        }
        auto it = unique(intervals.begin(), intervals.end());
        intervals.resize(distance(intervals.begin(), it));
        return intervals;
    }
};
```

## 【前缀和、思维】[力扣2145. 统计隐藏数组数目](https://leetcode.cn/problems/count-the-hidden-sequences/)

### 方法：前缀和+数学

可以通过前缀和得到一个波峰波谷作为约束条件，我们需要确保波峰不超过upper，波谷不小于lower，得到一个关于x的不等式，满足这个不等式的x的个数即为答案。

注意：

- 会爆long long 

- 记得判掉不合法条件，需要满足`L <= x <= R`

### 代码：

```c++
class Solution {
public:
    using i64 = long long;
    int numberOfArrays(vector<int>& differences, int lower, int upper) {
        int n = differences.size() + 1;
        vector<i64> sum(n, 0);
        
        for (int i = 1; i < n; i++) {
            sum[i] += sum[i - 1] + differences[i - 1];
        }

        i64 mx = *max_element(sum.begin(), sum.end());
        i64 mi = *min_element(sum.begin(), sum.end());
        i64 r = upper - mx;
        i64 l = lower - mi;
        // 区间上不合法
        if (r < l) {
            return 0;
        }
        i64 res = r - l + 1;
        return res;
    }
};
/*
推导如下：
For Example 1: differences => 1, -3, 4 ; lower=1, upper=6

x x+1 x-2 x+2
1) x + 2 <= 6
2) x - 2 >= 1
=> 3 <= x <= 4

For Example 2: differences => 3,-4,5,1,-2 ; lower=-4, upper=5
x x+3 x-1 x+4 x+5 x+3
1) x + 5 <= 5
2) x - 1 >= -4
=> -3 <= x <= 0

For Example 3: differences => -40 ; lower=-46, upper=53
x x-40
1) x - 40 >= -46
2) x <=53
=> -6 <= x <= 53
*/
```

## 小结

1. 复健day1有点拉
2. 收获语法糖：

- `vector`取最后一个元素`vector arr; arr.back()`